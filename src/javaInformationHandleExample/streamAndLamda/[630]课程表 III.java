//这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。 
//
// 给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。 
//
// 
//
// 示例： 
//
// 
//输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
//输出: 3
//解释: 
//这里一共有 4 门课程, 但是你最多可以修 3 门:
//首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
//第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
//第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
//第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。 
//
// 
//
// 提示: 
//
// 
// 整数 1 <= d, t, n <= 10,000 。 
// 你不能同时修两门课程。 
// 
//
// 
// Related Topics 贪心算法



//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int scheduleCourse(int[][] courses) {
        /**
         *  算法步骤
         *  （1）按照结束时间对课程进行排序
         *  （2）使用一个大顶堆来储存已经选择的课程的长度
         *  （3）一旦发现安排了当前课程之后，其结束时间超过了最晚结束时间，那么就从已经安排的课程中，取消掉一门最耗时的课程
         */
        // 贪心算法：谁限制时间紧，先考虑学谁（数组排序），再考虑花费时间，谁花的时间多先学谁（优先队列队首，即堆顶）
        // 先说重要步骤再说原理：
        //  1、将所有课程按限制时间由小到大排列数组，一个一个加入优先队列（队列顺序按花费时间由大到小排序）
        //  2、如果学完 当前这门课 要花费的时间c[0] + 已经花费的时间 x 比 当前这门课 的限制时间c[1] 短，就加上这门课
        //  3、如果长，就看队列第一个花费的时间c[0] 是不是比 当前这个课的时间c[0]短，如果长，就把队列第一个（限制时间最紧，花费时间最多）poll出去
        //  4、因为只需要判断有几门课程不需要判断具体哪几门，所以优先队列中有几门课就是最终答案
        Arrays.sort(courses, (a, b) -> a[1] - b[1]); // 限制时间从小到大
        PriorityQueue<Integer> pqueue = new PriorityQueue<>((a, b) -> b - a); // 花费时间从大到小
        int x = 0;
        for (int c[] : courses){
            if (c[0] + x <= c[1]){ // 对应步骤2
                pqueue.add(c[0]);
                x += c[0];
            }else if (!pqueue.isEmpty() && pqueue.peek() > c[0]){ // 对应步骤3
                x += c[0] - pqueue.poll();
                pqueue.add(c[0]);
            }
        }
        return pqueue.size();

    }
}
//leetcode submit region end(Prohibit modification and deletion)
